.. _config_files:

===================
Configuration Files
===================

PyOxidizer uses `Starlark <https://github.com/bazelbuild/starlark>`_
files to configure run-time behavior.

Starlark is a dialect of Python intended to be used as a configuration
language and the syntax should be familiar to any Python programmer.

Finding Configuration Files
===========================

The Starlark configuration file is processed as part of building the ``pyembed``
crate. This is the crate that manages an embedded Python interpreter in a
larger Rust project.

If the ``PYOXIDIZER_CONFIG`` environment variable is set, the path specified
by this environment variable will be used as the location of the Starlark
configuration file.

If ``PYOXIDIZER_CONFIG`` is not set, the build will look for a
``pyoxidizer.bzl`` file starting in the directory of the ``pyembed``
crate and then traversing ancestor directories until a file is found.

If no configuration file is found, an error occurs.

File Processing Semantics
=========================

A configuration file is evaluated in a custom Starlark *dialect* which
provides primitives used by PyOxidizer. This dialect provides some
well-defined global variables (defined in UPPERCASE) as well as some
types and functions that can be constructed and called. (See their
definitions below.)

A configuration file is effectively a sandboxed Python script. As
functions are called, PyOxidizer will perform actions as described
by those functions.

Configuration files define functions which perform some activity
then register these functions under a *target* name via the
``register_target()`` global function. When a configuration
file is evaluated, PyOxidizer attempts to resolve an ordered set of
*targets*. This means that configuration files are effectively a mini
build system, albeit without the complexity and features that a fully
generic build system entails.

Global Environment
==================

The evaluation context takes place in a *global environment*.

This environment contains
`built-in symbols and constants from Starlark <https://github.com/bazelbuild/starlark/blob/master/spec.md#built-in-constants-and-functions>`_
in addition to symbols and constants provided by PyOxidizer. The
following sections describe those symbols.

Global Constants
================

PyOxidizer provides global constants as defined by the following sections.

BUILD_TARGET_TRIPLE
-------------------

The string Rust target triple that we're currently building for. Will be
a value like ``x86_64-unknown-linux-gnu`` or ``x86_64-pc-windows-msvc``.
Run ``rustup target list`` to see a list of targets.

CONFIG_PATH
-----------

The string path to the configuration file currently being evaluated.

CONTEXT
-------

Holds build context. This is an internal variable and accessing it will
not provide any value.

CWD
---

The current working directory. Also the directory containing the active
configuration file.

Global Symbols
==============

PyOxidizer defines various global symbols to define execution
behavior. These are explained in the following sections.

register_target(name, fn)
-------------------------

Registers a named target that can be resolved by the configuration file.

A target consists of a string name and a callable function, which may return
a primitive representing the evaluation result.

resolve_target(target)
----------------------

Triggers resolution of a requested build target.

This function resolves a target registered with ``register_target()`` by
calling the target's registered function or returning the previously
resolved value from calling it.

This function should be used in cases where 1 target depends on the
resolved value of another target. For example, a target to create a
``FileManifest`` may wish to add a ``PythonExecutable`` that was resolved
from another target.

resolve_targets()
-----------------

Triggers resolution of requested build targets.

This is usually the last meaningful line in a config file. It triggers the
building of targets which have been requested to resolve by whatever is invoking
the config file.

set_build_path(path)
--------------------

Configure the directory where build artifacts will be written.

Build artifacts include Rust build state, files generated by PyOxidizer,
staging areas for built binaries, etc.

The default value is ``$CWD/build``.

.. important::

   This needs to be called before functionality that utilizes the build path,
   otherwise the default value will be used.

.. _config_python_distribution:

``PythonDistribution(sha256, local_path=None, url=None)``
---------------------------------------------------------

Defines a Python distribution that can be embedded into a binary.

A Python distribution is a zstandard-compressed tar archive containing a
specially produced build of Python. These distributions are typically
produced by the
`python-build-standalone <https://github.com/indygreg/python-build-standalone>`_
project. Pre-built distributions are available at
https://github.com/indygreg/python-build-standalone/releases.

A distribution is defined by a location, and a hash.

One of ``local_path`` or ``url`` MUST be defined.

``sha256`` (string)
   The SHA-256 of the distribution archive file.

``local_path`` (string)
   Local filesystem path to the distribution archive.

``url`` (string)
   URL from which a distribution archive can be obtained using an HTTP GET
   request.

Examples:

.. code-block:: python

   linux = PythonDistribution(
       sha256="11a53f5755773f91111a04f6070a6bc00518a0e8e64d90f58584abf02ca79081",
       local_path="/var/python-distributions/cpython-linux64.tar.zst"
   )

   macos = PythonDistribution(
        sha256="b46a861c05cb74b5b668d2ce44dcb65a449b9fef98ba5d9ec6ff6937829d5eec",
        url="https://github.com/indygreg/python-build-standalone/releases/download/20190505/cpython-3.7.3-macos-20190506T0054.tar.zst"
   )

``PythonDistribution.source_modules()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Returns a ``list`` of ``PythonSourceModule`` representing Python
source modules present in this distribution.

``PythonDistribution.resources_data(include_test=False)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Returns a ``list`` of ``PythonResourceData`` representing resource files
present in this distribution.

The ``include_test`` boolean argument controls whether resources associated
with test packages are included.

.. _config_python_distribution_extension_modules:

``PythonDistribution.extension_modules(filter='all', preferred_variants=None)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Returns a ``list`` of ``PythonExtensionModule`` representing extension
modules in this distribution.

The ``filter`` argument denotes how to filter the extension modules. The
following values are recognized:

``all``
   Every named extension module will be included.

``minimal``
   Return only extension modules that are required to initialize a
   Python interpreter. This is a very small set and various functionality
   from the Python standard library will not work with this value.

``no-libraries``
   Return only extension modules that don't require any additional libraries.

   Most common Python extension modules are included. Extension modules
   like ``_ssl`` (links against OpenSSL) and ``zlib`` are not included.

``no-gpl``
   Return only extension modules that do not link against GPL licensed
   libraries.

   Not all Python distributions may annotate license info for all extensions or
   the libraries they link against. If license info is missing, the extension is
   not included because it *could* be GPL licensed. Similarly, the mechanism for
   determining whether a license is GPL is based on an explicit list of non-GPL
   licenses. This ensures new GPL licenses don't slip through.

The ``preferred_variants`` argument denotes a string to string mapping of
extension module name to its preferred variant name. If multiple variants of
an extension module meet the filter requirements, the preferred variant from
this mapping will be used. Otherwise the first variant will be used.

.. important::

   Libraries that extension modules link against have various software
   licenses, including GPL version 3. Adding these extension modules will
   also include the library. This typically exposes your program to additional
   licensing requirements, including making your application subject to that
   license and therefore open source. See :ref:`licensing_considerations` for
   more.

``PythonDistribution.pip_install(args, extra_envs={})``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method runs ``pip install <args>`` with the specified distribution.

``args``
   List of strings defining raw process arguments to pass to ``pip install``.

``extra_envs``
   Optional dict of string key-value pairs constituting extra environment
   variables to set in the invoked ``pip`` process.

Returns a ``list`` of objects representing Python resources installed as
part of the operation. The types of these objects can be ``PythonSourceModule``,
``PythonBytecodeModule``, ``PythonResourceData``, etc.

The returned resources are typically added to a ``FileManifest`` or
``PythonEmbeddedResources`` to make them available to a packaged
application.

``PythonDistribution.read_package_root(path, packages)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method discovers resources from a directory on the filesystem.

The specified directory will be scanned for resource files. However,
only specific named *packages* will be found. e.g. if the directory
contains sub-directories ``foo/`` and ``bar``, you must explicitly
state that you want the ``foo`` and/or ``bar`` package to be included
so files from these directories will be read.

This rule is frequently used to pull in packages from local source
directories (e.g. directories containing a ``setup.py`` file). This
rule doesn't involve any packaging tools and is a purely driven by
filesystem walking. It is primitive, yet effective.

This rule has the following arguments:

``path`` (string)
   The filesystem path to the directory to scan.

``packages`` (list of string)
   List of package names to include.

   Filesystem walking will find files in a directory ``<path>/<value>/`` or in
   a file ``<path>/<value>.py``.

Returns a ``list`` of objects representing Python resources found in the virtualenv.
The types of these objects can be ``PythonSourceModule``, ``PythonBytecodeModule``,
``PythonResourceData``, etc.

The returned resources are typically added to a ``FileManifest`` or
``PythonEmbeddedResources`` to make them available to a packaged
application.

``PythonDistribution.read_virtualenv(path)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method attempts to read Python resources from an already built
virtualenv.

.. important::

   PyOxidizer only supports finding modules and resources
   populated via *traditional* means (e.g. ``pip install`` or ``python setup.py
   install``). If ``.pth`` or similar mechanisms are used for installing modules,
   files may not be discovered properly.

It accepts the following arguments:

``path`` (string)
   The filesystem path to the root of the virtualenv.

   Python modules are typically in a ``lib/pythonX.Y/site-packages`` directory
   (on UNIX) or ``Lib/site-packages`` directory (on Windows) under this path.

Returns a ``list`` of objects representing Python resources found in the virtualenv.
The types of these objects can be ``PythonSourceModule``, ``PythonBytecodeModule``,
``PythonResourceData``, etc.

The returned resources are typically added to a ``FileManifest`` or
``PythonEmbeddedResources`` to make them available to a packaged
application.

``PythonDistribution.setup_py_install(...)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method runs ``python setup.py install`` against a package at the
specified path.

It accepts the following arguments:

``package_path``
   String filesystem path to directory containing a ``setup.py`` to invoke.

``extra_envs={}``
   Optional dict of string key-value pairs constituting extra environment
   variables to set in the invoked ``python`` process.

``extra_global_arguments=[]``
   Optional list of strings of extra command line arguments to pass to
   ``python setup.py``. These will be added before the ``install``
   argument.

Returns a ``list`` of objects representing Python resources installed
as part of the operation. The types of these objects can be
``PythonSourceModule``, ``PythonBytecodeModule``, ``PythonResourceData``,
etc.

The returned resources are typically added to a ``FileManifest`` or
``PythonEmbeddedResources`` to make them available to a packaged application.

``PythonDistribution.to_embedded_resources(...)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Construct a ``PythonEmbeddedResources`` from a ``PythonDistribution`` instance,
with control over common settings.

The arguments are as follows:

``extension_module_filter`` (``str``)
   The filter to apply to determine which extension modules to add.

   See :ref:`config_python_distribution_extension_modules`_ for what
   values are accepted and their behavior.

   Default is ``all``.

``preferred_extension_module_variants`` (``dict`` of ``string`` to ``string``)
   Preferred extension module variants to use. See
   See :ref:`config_python_distribution_extension_modules`_ for behavior.

   Default is ``None``, which will use the first variant.

``include_sources`` (``bool``)
   Boolean to control whether sources of Python modules are added in addition
   to bytecode.

   Default is ``True``.

``include_resources`` (``bool``)
   Boolean to control whether non-module resource data from the distribution is
   added.

   Default is ``False``.

``include_test`` (``bool``)
   Boolean to control whether test-specific objects are included.

   Default is ``False``.

``default_python_distribution(build_target=None)``
--------------------------------------------------

Resolves the default ``PythonDistribution`` for the given build target,
which defaults to the active build target as defined by ``BUILD_TARGET``.

The ``pyoxidizer`` binary has a set of known distributions built-in
which are automatically available and used by default in autogenerated
config files. Typically you don't need to build your own distribution or
change the distribution manually: distributions are managed automatically
by ``pyoxidizer``.

``PythonSourceModule``
----------------------

This type represents Python source modules, agnostic of location.

Each instance has the following attributes:

``name`` (string)
   Fully qualified name of the module. e.g. ``foo.bar``.

``is_package`` (bool)
   Whether this module is also a Python package (or sub-package).

Instances cannot be manually constructed.

``PythonBytecodeModule``
------------------------

This type represents a Python module defined through bytecode.

Each instance has the following attributes:

``name`` (string)
   Fully qualified name of the module. e.g. ``foo.bar``

``optimize_level`` (int)
   Optimization level of compiled bytecode. Must be the value
  ``0``, ``1``, or ``2``.

``is_package`` (bool)
   Whether the module is also a Python package (or sub-package).

``PythonResourcesData``
-----------------------

This type represents Python resource data. Resource data is a named
blob associated with a Python package. It is typically accessed using
the ``importlib.resources`` API.

Each instance has the following attributes:

``package`` (string)
   Python package this resource is associated with.

``name`` (string)
   Name of this resource.

``PythonExtensionModule``
-------------------------

This type represents a compiled Python extension module.

Each instance has the following attributes:

``name`` (string)
   Unique name of the module being provided.

``PythonEmbeddedResources()``
-----------------------------

This type represents Python resources to embed in a Python binary.

This type is effectively a meta type representing collections of
different resource classes. Those resource classes include:

* Python modules as defined by Python source code.
* Python modules as defined by Python bytecode.
* Compiled Python extension modules.
* Resource files loadable through Python's ``importlib.resources``
  API.

``PythonEmbeddedResources.add_module_source(module)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method registers a Python source module with a ``PythonEmbeddedResources``
instance. The argument must be a ``PythonSourceModule`` instance.

If called multiple times for the same module, the last write wins.

``PythonEmbeddedResources.add_module_bytecode(module, optimize_level=0)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method registers a Python module bytecode with a
``PythonEmbeddedResources`` instance. The first argument must be a
``PythonSourceModule`` instance and the 2nd argument the value ``0``, ``1``,
or ``2``.

Only one level of bytecode can be registered per named module. If called
multiple times for the same module, the last write wins.

``PythonEmbeddedResources.add_resource_data(resource)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method adds a ``PythonResourceData`` instance to the
``PythonEmbeddedResources`` instance, making that resource available
via in-memory access.

If multiple resources sharing the same ``(package, name)`` pair are added,
the last added one is used.

``PythonEmbeddedResources.add_extension_module(module)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method registers a ``PythonExtensionModule`` instance with a
``PythonEmbeddedResources`` instance. The extension module will be statically
linked into the binary produced from the ``PythonEmbeddedResources``
instance.

If multiple extension modules with the same name are added, the last
added one is used.

``PythonEmbeddedResources.add_python_resource(...)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method registers a Python resource of various types. It accepts a
``resource`` argument which can be a ``PythonSourceModule``,
``PythonBytecodeModule``, ``PythonResourceData``, or ``PythonExtensionModule``
and registers that resource with this instance. This method is a glorified
proxy to the appropriate ``add_*`` method.

The following arguments are accepted:

``resource``
   The resource to add to the embedded Python environment.

``add_source_module`` (bool)
   When the resource is a ``PythonSourceModule``, this flag determines
   whether to add the source for that resource.

   Default is ``True``.

``add_bytecode_module`` (bool)
   When the resource is a ``PythonSourceModule``, this flag determines
   whether to add the bytecode for that module source.

   Default is ``True``.

``optimize_level`` (int)
   Bytecode optimization level when compiling bytecode.

``PythonEmbeddedResources.add_python_resources(...)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method registers an iterable of Python resources of various types.
This method is identical to ``PythonEmbeddedResources.add_python_resource()``
except the first argument is an iterable of resources. All other arguments
are identical.

``PythonEmbeddedResources.filter_from_files(files=[], glob_patterns=[])``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method filters all embedded resources (source modules, bytecode modules,
and resource names) currently present on the instance through a set of
resource names resolved from files.

This method accepts the following arguments:

``files`` (array of string)
   List of filesystem paths to files containing resource names. The file
   must be valid UTF-8 and consist of a ``\n`` delimited list of resource
   names. Empty lines and lines beginning with ``#`` are ignored.

``glob_files`` (array of string)
   List of glob matching patterns of filter files to read. ``*`` denotes
   all files in a directory. ``**`` denotes recursive directories. This
   uses the Rust ``glob`` crate under the hood and the documentation for that
   crate contains more pattern matching info.

   The files read by this argument must be the same format as documented
   by the ``files`` argument.

All defined files are first read and the resource names encountered are
unioned into a set. This set is then used to filter entities currently
registered with the instance.

.. _config_embedded_python_config:

``EmbeddedPythonConfig(...)```
------------------------------

This type configures the default behavior of the embedded Python interpreter.

Embedded Python interpreters are configured and instantiated using a
``pyembed::PythonConfig`` data structure. The ``pyembed`` crate defines a
default instance of this data structure with parameters defined by the settings
in this type.

.. note::

   If you are writing custom Rust code and constructing a custom
   ``pyembed::PythonConfig`` instance and don't use the default instance, this
   config type is not relevant to you and can be omitted from your config
   file.

The following arguments can be defined to control the default ``PythonConfig``
behavior:

``bytes_warning`` (int)
   Controls the value of
   ``Py_BytesWarningFlag <https://docs.python.org/3/c-api/init.html#c.Py_BytesWarningFlag>`_.

   Default is ``0``.

``dont_write_bytecode`` (bool)
   Controls the value of
   `Py_DontWriteBytecodeFlag <https://docs.python.org/3/c-api/init.html#c.Py_DontWriteBytecodeFlag>`_.

   This is only relevant if the interpreter is configured to import modules
   from the filesystem.

   Default is ``True``.

``ignore_environment`` (bool)
   Controls the value of
   `Py_IgnoreEnvironmentFlag <https://docs.python.org/3/c-api/init.html#c.Py_IgnoreEnvironmentFlag>`_.

   This is likely wanted for embedded applications that don't behave like
   ``python`` executables.

   Default is ``True``.

``inspect`` (bool)
   Controls the value of
   `Py_InspectFlag <https://docs.python.org/3/c-api/init.html#c.Py_InspectFlag>`_.

   Default is ``False``.

``interactive`` (bool)
   Controls the value of
   `Py_InteractiveFlag <https://docs.python.org/3/c-api/init.html#c.Py_InspectFlag>`_.

   Default is ``False``.

``isolated`` (bool)
   Controls the value of
   `Py_IsolatedFlag <https://docs.python.org/3/c-api/init.html#c.Py_IsolatedFlag>`_.

``legacy_windows_fs_encoding`` (bool)
   Controls the value of
   `Py_LegacyWindowsFSEncodingFlag <https://docs.python.org/3/c-api/init.html#c.Py_LegacyWindowsFSEncodingFlag>`_.

   Only affects Windows.

   Default is ``False``.

``legacy_windows_stdio`` (bool)
   Controls the value of
   `Py_LegacyWindowsStdioFlag <https://docs.python.org/3/c-api/init.html#c.Py_LegacyWindowsStdioFlag>`_.

   Only affects Windows.

   Default is ``False``.

``no_site`` (bool)
   Controls the value of
   `Py_NoSiteFlag <https://docs.python.org/3/c-api/init.html#c.Py_NoSiteFlag>`_.

   The ``site`` module is typically not needed for standalone Python applications.

   Default is ``True``.

``no_user_site_directory`` (bool)
   Controls the value of
   `Py_NoUserSiteDirectory <https://docs.python.org/3/c-api/init.html#c.Py_NoUserSiteDirectory>`_.

   Default is ``True``.

``optimize_level`` (bool)
   Controls the value of
   `Py_OptimizeFlag <https://docs.python.org/3/c-api/init.html#c.Py_OptimizeFlag>`_.

   Default is ``0``, which is the Python default. Only the values ``0``, ``1``,
   and ``2`` are accepted.

   This setting is only relevant if ``dont_write_bytecode`` is ``false`` and Python
   modules are being imported from the filesystem.

``parser_debug`` (bool)
   Controls the value of
   `Py_DebugFlag <https://docs.python.org/3/c-api/init.html#c.Py_DebugFlag>`_.

   Default is ``False``.

``quiet`` (bool)
   Controls the value of
   `Py_QuietFlag <https://docs.python.org/3/c-api/init.html#c.Py_QuietFlag>`_.

``stdio_encoding`` (string)
   Defines the encoding and error handling mode for Python's standard I/O
   streams (``sys.stdout``, etc). Values are of the form ``encoding:error`` e.g.
   ``utf-8:ignore`` or ``latin1-strict``.

   If defined, the ``Py_SetStandardStreamEncoding()`` function is called during
   Python interpreter initialization. If not, the Python defaults are used.

``unbuffered_stdio`` (bool)
   Controls the value of
   `Py_UnbufferedStdioFlag <https://docs.python.org/3/c-api/init.html#c.Py_UnbufferedStdioFlag>`_.

   Setting this makes the standard I/O streams unbuffered.

   Default is ``False``.

``use_hash_seed`` (bool)
   Controls the value of
   `https://docs.python.org/3/c-api/init.html#c.Py_HashRandomizationFlag`_.

   Default is ``False``.

``filesystem_importer`` (bool)
   Controls whether to enable Python's filesystem based importer. Enabling
   this importer allows Python modules to be imported from the filesystem.

   Default is ``False`` (since PyOxidizer prefers embedding Python modules in
   binaries).

``sys_frozen`` (bool)
   Controls whether to set the ``sys.frozen`` attribute to ``True``. If
   ``false``, ``sys.frozen`` is not set.

   Default is ``False``.

``sys_meipass`` (bool)
   Controls whether to set the ``sys._MEIPASS`` attribute to the path of
   the executable.

   Setting this and ``sys_frozen`` to ``true`` will emulate the
   `behavior of PyInstaller <https://pyinstaller.readthedocs.io/en/v3.3.1/runtime-information.html>`_
   and could possibly help self-contained applications that are aware of
   PyInstaller also work with PyOxidizer.

   Default is ``False``.

``sys_paths`` (array of strings)
   Defines filesystem paths to be added to ``sys.path``.

   Setting this value will imply ``filesystem_importer = true``.

   The special token ``$ORIGIN`` in values will be expanded to the absolute
   path of the directory of the executable at run-time. For example,
   if the executable is ``/opt/my-application/pyapp``, ``$ORIGIN`` will
   expand to ``/opt/my-application`` and the value ``$ORIGIN/lib`` will
   expand to ``/opt/my-application/lib``.

   If defined in multiple sections, new values completely overwrite old
   values (values are not merged).

   Default is an empty array (``[]``).

``raw_allocator`` (string)
   Which memory allocator to use for the ``PYMEM_DOMAIN_RAW`` allocator.

   This controls the lowest level memory allocator used by Python. All Python
   memory allocations use memory allocated by this allocator (higher-level
   allocators call into this pool to allocate large blocks then allocate
   memory out of those blocks instead of using the *raw* memory allocator).

   Values can be ``jemalloc``, ``rust``, or ``system``.

   ``jemalloc`` will have Python use the jemalloc allocator directly.

   ``rust`` will use Rust's global allocator (whatever that may be).

   ``system`` will use the default allocator functions exposed to the binary
   (``malloc()``, ``free()``, etc).

   The ``jemalloc`` allocator requires the ``jemalloc-sys`` crate to be
   available. A run-time error will occur if ``jemalloc`` is configured but this
   allocator isn't available.

   **Important**: the ``rust`` crate is not recommended because it introduces
   performance overhead.

   Default is ``jemalloc`` on non-Windows targets and ``system`` on Windows.
   (The ``jemalloc-sys`` crate doesn't work on Windows MSVC targets.)

.. _config_terminfo_resolution:

``terminfo_resolution`` (string)
   How the terminal information database (``terminfo``) should be configured.

   See :ref:`terminfo_database` for more about terminal databases.

   The value ``dynamic`` (the default) looks at the currently running
   operating system and attempts to do something reasonable. For example, on
   Debian based distributions, it will look for the ``terminfo`` database in
   ``/etc/terminfo``, ``/lib/terminfo``, and ``/usr/share/terminfo``, which is
   how Debian configures ``ncurses`` to behave normally. Similar behavior exists
   for other recognized operating systems. If the operating system is unknown,
   PyOxidizer falls back to looking for the ``terminfo`` database in well-known
   directories that often contain the database (like ``/usr/share/terminfo``).

   The value ``none`` indicates that no configuration of the ``terminfo``
   database path should be performed. This is useful for applications that
   don't interact with terminals. Using ``none`` can prevent some filesystem
   I/O at application startup.

   The value ``static`` indicates that a static path should be used for the
   path to the ``terminfo`` database. That path should be provided by the
   ``terminfo_dirs`` configuration option.

   ``terminfo`` is not used on Windows and this setting is ignored on that
   platform.

``terminfo_dirs``
   Path to the ``terminfo`` database. See the above documentation for
   ``terminfo_resolution`` for more on the ``terminfo`` database.

   This value consists of a ``:`` delimited list of filesystem paths that
   ``ncurses`` should be configured to use. This value will be used to
   populate the ``TERMINFO_DIRS`` environment variable at application run time.

``write_modules_directory_env`` (string)
   Environment variable that defines a directory where ``modules-<UUID>`` files
   containing a ``\n`` delimited list of loaded Python modules (from ``sys.modules``)
   will be written upon interpreter shutdown.

   If this setting is not defined or if the environment variable specified by its
   value is not present at run-time, no special behavior will occur. Otherwise,
   the environment variable's value is interpreted as a directory, that directory
   and any of its parents will be created, and a ``modules-<UUID>`` file will
   be written to the directory.

   This setting is useful for determining which Python modules are loaded when
   running Python code.

.. _config_embedded_python_run:

Python Run Mode
---------------

Embedded Python interpreters are configured and instantiated using a
``pyembed::PythonConfig`` data structure. The ``pyembed`` crate defines a
default instance of this data structure with parameters defined by a
``PythonRunMode`` instance.

.. note::

   If you are writing custom Rust code and constructing a custom
   ``pyembed::PythonConfig`` instance and don't use the default instance, this
   config section is not relevant to you and can be omitted from your config
   file.

The sections below denote ways of constructing ``PythonRunMode``
instances.

``python_run_mode_eval(code)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This mode will evaluate a string containing Python code after the
interpreter initializes.

This mode requires the ``code`` argument to be set to a string containing
Python code to run.

Example:

.. code-block:: python

   python_run_mode = python_run_mode_eval("import mymodule; mymodule.main()")

``python_run_mode_module(module)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This mode will load a named Python module as the ``__main__`` module and
then execute that module.

This mode requires the ``module`` argument to be set to the string value of
the module to load as ``__main__``.

Example:

.. code-block:: python

   python_run_mode = python_run_mode_module("mymodule")

``python_run_mode_repl()``
^^^^^^^^^^^^^^^^^^^^^^^^^^

This mode will launch an interactive Python REPL connected to stdin. This
is similar to the behavior of running a ``python`` executable without any
arguments.

Example:

.. code-block:: python

   python_run_mode = python_run_mode_repl()

``python_run_mode_noop()``
^^^^^^^^^^^^^^^^^^^^^^^^^^

This mode will do nothing. It is provided for completeness sake.

``PythonExecutable(...)``
-------------------------

The ``PythonExecutable`` type represents an executable file containing
the Python interpreter, Python resources to make available to the interpreter,
and a default run-time configuration for that interpreter.

Instances are constructed by passing arguments to a ``PythonExecutable()``
function. The accepted arguments are:

``name`` (``str``)
   The name of the application being built. This will be used to construct the
   default filename of the executable.

``distribution`` (``PythonDistribution``)
   The Python distribution to use to construct this executable. The
   interpreter from the distribution will be compiled into the produced
   executable.

``resources`` (``PythonEmbeddedResources``)
   Python resources to make available to the embedded interpreter.

``config`` (``PythonEmbeddedConfig``)
   The default configuration of the embedded Python interpreter.

``run_mode`` (``PythonRunMode``)
   The default run-time behavior of the embedded Python interpreter.

``FileManifest()``
------------------

The ``FileManifest`` type represents a set of files and their content.

``FileManifest`` instances are used to represent things like the final
filesystem layout of an installed application.

Conceptually, a ``FileManifest`` is a dict mapping relative paths to
file content.

``FileManifest.add_python_resource(prefix, value)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method adds a Python resource to a ``FileManifest`` instance in
a specified directory prefix. A *Python resource* here can be a
``PythonSourceModule``, ``PythonBytecodeModule``, ``PythonResourceData``,
or ``PythonExtensionModule``.

This method can be used to place the Python resources derived from another
type or action in the filesystem next to an application binary.

``FileManifest.add_python_resources(prefix, values)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method adds an iterable of Python resources to a ``FileManifest``
instance in a specified directory prefix. This is effectively a wrapper
for ``for value in values: self.add_python_resource(prefix, value)``.

For example, to place the Python distribution's standard library Python
source modules in a directory named ``lib``::

   m = FileManifest()
   dist = default_python_distribution()
   m.add_python_resources(dist.source_modules())

``FileManifest.install(path, replace=True)``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This method writes the content of the ``FileManifest`` to a directory
specified by ``path``. The path is evaluated relative to the path
specified by ``BUILD_PATH``.

If ``replace`` is True (the default), the destination directory will
be deleted and the final state of the destination directory should
exactly match the state of the ``FileManifest``.

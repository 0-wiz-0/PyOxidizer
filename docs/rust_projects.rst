.. _rust_projects:

=============
Rust Projects
=============

PyOxidizer uses Rust projects to build binaries embedding Python.

If you just have a standalone configuration file (such as when running
``pyoxidizer init-config-file``), a temporary Rust project will be
created as part of building binaries and the existence of Rust should
be largely invisible (except for the output from building the Rust project).

If you use ``pyoxidizer init-rust-project`` to initialize a
``PyOxidizer`` application, the Rust project exists side-by-side with
the ``PyOxidizer`` configuration file and can be modified like
any other Rust project.

Either way, the ``PyOxidizer`` configuration file works alongside Rust
to build binaries.

.. _rust_project_layout:

Layout
======

Generated Rust projects all have a similar layout::

   $ find pyapp -type f | grep -v .git
   Cargo.toml
   src/main.rs

Main Application Project
========================

The ``Cargo.toml`` file is the configuration file for the Rust project.
Read more in
`the official Cargo documentation <https://doc.rust-lang.org/cargo/reference/manifest.html>`_.
The magic lines in this file to enable PyOxidizer are the following::

   [dependencies]
   pyembed = ...

These lines declare a dependency on the ``pyembed`` package, which holds
all the smarts for embedding Python in a binary.

Next let's look at ``pyapp/src/main.rs``. If you aren't familiar with Rust
projects, the ``src/main.rs`` file is the default location for the source
file implementing an executable. If we open that file, we see a
``fn main() {`` line, which declares the *main* function for our executable.
The file is relatively straightforward. We import some symbols from the
``pyembed`` crate. We then construct a config object, use that to construct
a Python interpreter, then we run the interpreter and pass its exit code
to ``exit()``. Succinctly, we instantiate and run an embedded Python
interpreter. That's our executable.

Build Artifacts for ``pyembed``
===============================

The ``pyembed`` crate needs to reference special artifacts as part of its
build process in order to compile a Python interpreter into a binary.

These special artifacts are generated by the ``pyembed`` crate's ``build.rs``
build script. This file defines a program that runs as part of building the
crate. The main goal of the ``build.rs`` script is to read the auto-generated
artifact defining metadata needed by Rust's build system and to print it.
In order to do so, it may need to invoke ``PyOxidizer`` to generate this
metadata file.

The build artifacts required by ``pyembed`` are generated by resolving
a configuration file target returning a :ref:`config_python_embedded_data`
instance. In the auto-generated ``pyoxidizer.bzl`` configuration file, the
``embedded`` target facilitates this purpose.

There are multiple ways for the ``build.rs`` script to invoke ``PyOxidizer``.

The default option is to call ``pyoxidizer run-build-script``. This command
is a special variation of ``pyoxidizer build`` that knows it is running in
the context of a Rust build script and it will take appropriate actions.
For example, artifacts required by ``pyembed`` will be written to ``OUT_DIR``,
In addition, the content of the generated ``cargo_metadata.txt`` file is
printed so the ``pyembed`` crate is properly configured to embed Python.

Under the hood, ``pyoxidizer run-build-script`` calls a function inside
the ``pyoxidizer`` crate. Should the build script wish to avoid the dependency
on a ``pyoxidizer`` executable and call the equivalent code as a library
(by compiling ``PyOxidizer`` as a build dependency), it can do so. The
function it should call is
``pyoxidizerlib::project_building::run_from_build()``. An example of this
is included in the auto-generated ``build.rs`` script when running
``pyoxidizer init-rust-project``.

A final option for the build script is to not invoke ``PyOxidizer`` directly
and instead rely on artifacts built out of band. In this case, all you need
to do is read the ``cargo_metadata.txt`` file generated by ``PyOxidizer``
and print its contents.

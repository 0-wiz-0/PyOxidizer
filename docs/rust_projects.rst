.. _rust_projects:

=============
Rust Projects
=============

PyOxidizer uses Rust projects to build binaries embedding Python.

If you just have a standalone configuration file (such as when running
``pyoxidizer init-config-file``), a temporary Rust project will be
created as part of building binaries and the existence of Rust should
be largely invisible (except for the output from building the Rust project).

If you use ``pyoxidizer init-rust-project`` to initialize a
``PyOxidizer`` application, the Rust project exists side-by-side with
the ``PyOxidizer`` configuration file and can be modified like
any other Rust project.

Either way, the ``PyOxidizer`` configuration file works alongside Rust
to build binaries.

.. _rust_project_layout:

Layout
======

Generated Rust projects all have a similar layout::

   $ find pyapp -type f | grep -v .git
   Cargo.toml
   pyoxidizer.bzl
   src/main.rs

The ``Cargo.toml`` file is the configuration file for the Rust project.
Read more in
`the official Cargo documentation <https://doc.rust-lang.org/cargo/reference/manifest.html>`_.
The magic lines in this file to enable PyOxidizer are the following::

   [dependencies]
   pyembed = ...

These lines declare a dependency on the ``pyembed`` package, which holds
all the smarts for embedding Python in a binary.

Next let's look at ``src/main.rs``. If you aren't familiar with Rust
projects, the ``src/main.rs`` file is the default location for the source
file implementing an executable. If we open that file, we see a
``fn main() {`` line, which declares the *main* function for our executable.
The file is relatively straightforward. We import some symbols from the
``pyembed`` crate. We then construct a config object, use that to construct
a Python interpreter, then we run the interpreter and pass its exit code
to ``exit()``. Succinctly, we instantiate and run an embedded Python
interpreter. That's our executable.

The ``pyoxidizer.bzl`` is our auto-generated
:ref:`PyOxidizer configuration file <config_files>`.

Build Artifacts for ``pyembed``
===============================

The ``pyembed`` crate needs to reference special artifacts as part of its
build process in order to compile a Python interpreter into a binary.

These special artifacts are ultimately generated by ``PyOxidizer``. How
exactly can vary.

By default, these special artifacts are generated by the ``pyembed`` crate's
``build.rs`` build script. Unless behavior is overridden via environment
variables, this program runs ``pyoxidizer run-build-script`` to generate
these special artifacts. That command will resolve the default build script
target in the found ``PyOxidizer`` configuration file.

The special build artifacts are generated by resolving a configuration file
target returning a :ref:`config_python_embedded_data` instance. In the
auto-generated configuration file, the ``embedded`` target returns such a
type.

Influencing ``pyembed`` Artifact Generation
===========================================

By default, the ``pyembed`` crate's build script will run
``pyoxidizer run-build-script`` using the ``pyoxidizer`` executable on
``PATH``.

To use a specific ``pyoxidizer`` executable, specify the ``PYOXIDIZER_EXE``
environment variable.

When ``pyoxidizer run-build-script`` runs, a ``PyOxidizer`` configuration
file will be discovered using the heuristics described at
:ref:`config_finding_configuration_files`. If running from the context of
``cargo build``, ``OUT_DIR`` is consulted the a ``pyoxidizer.bzl`` next to
the main Rust project being built should be used.

``pyoxidizer run-build-script`` will resolve the default build script
target by default. To override which target should be resolved, specify
the target name via the ``PYOXIDIZER_BUILD_TARGET`` environment variable. e.g.::

   $ PYOXIDIZER_BUILD_TARGET=pyembed-artifacts cargo build

If the build artifacts are already generated (perhaps you called
``pyoxidizer build`` or ``pyoxidizer run-build-script`` outside the context
of a normal ``cargo build``), you can tell the ``pyembed`` crate to use
build artifacts in a specific directory by setting the
``PYOXIDIZER_REUSE_ARTIFACTS`` environment variable to any value and the
``PYOXIDIZER_ARTIFACT_DIR`` environment variable to the directory containing
those artifacts. This directory **must** have a ``cargo_metadata.txt`` file,
which will be printed to stdout by the build script to tell Cargo how to
link a Python library.
